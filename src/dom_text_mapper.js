// Generated by CoffeeScript 1.6.3
(function() {
  var __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  window.DomTextMapper = (function() {
    var CONTEXT_LEN, SCAN_JOB_LENGTH_MS, SELECT_CHILDREN_INSTEAD, USE_EMPTY_TEXT_WORKAROUND, USE_TABLE_TEXT_WORKAROUND, WHITESPACE;

    USE_TABLE_TEXT_WORKAROUND = true;

    USE_EMPTY_TEXT_WORKAROUND = true;

    SELECT_CHILDREN_INSTEAD = ["thead", "tbody", "ol", "a", "caption", "p"];

    CONTEXT_LEN = 32;

    SCAN_JOB_LENGTH_MS = 100;

    DomTextMapper.instances = [];

    DomTextMapper.log = getXLogger("DomTextMapper class");

    DomTextMapper.changed = function(node, reason) {
      var dm, instance, _i, _len, _ref;
      if (reason == null) {
        reason = "no reason";
      }
      if (this.instances.length === 0) {
        return;
      }
      dm = this.instances[0];
      this.log.debug("Node @ " + (dm.getPathTo(node)) + " has changed: " + reason);
      _ref = this.instances;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        instance = _ref[_i];
        if (instance.rootNode.contains(node)) {
          instance.performSyncUpdateOnNode(node);
        }
      }
      return null;
    };

    function DomTextMapper(name) {
      this.log = getXLogger(name != null ? name : "dom-text-mapper");
      this.setRealRoot();
      DomTextMapper.instances.push(this);
    }

    DomTextMapper.prototype.setRootNode = function(rootNode) {
      this.rootWin = window;
      return this.pathStartNode = this.rootNode = rootNode;
    };

    DomTextMapper.prototype.setRootId = function(rootId) {
      return this.setRootNode(document.getElementById(rootId));
    };

    DomTextMapper.prototype.setRootIframe = function(iframeId) {
      var iframe;
      iframe = window.document.getElementById(iframeId);
      if (iframe == null) {
        throw new Error("Can't find iframe with specified ID!");
      }
      this.rootWin = iframe.contentWindow;
      if (this.rootWin == null) {
        throw new Error("Can't access contents of the specified iframe!");
      }
      this.rootNode = this.rootWin.document;
      return this.pathStartNode = this.getBody();
    };

    DomTextMapper.prototype.getDefaultPath = function() {
      return this.getPathTo(this.pathStartNode);
    };

    DomTextMapper.prototype.setRealRoot = function() {
      this.rootWin = window;
      this.rootNode = document;
      return this.pathStartNode = this.getBody();
    };

    DomTextMapper.prototype.documentChanged = function() {
      this.lastDOMChange = this.timestamp();
      return this.log.debug("Registered document change.");
    };

    DomTextMapper.prototype.scanSync = function() {
      var node, pathStart, startTime, t1, t2, task;
      if (this.domStableSince(this.lastScanned)) {
        this.log.debug("We have a valid DOM structure cache. Not scanning.");
        return this.path;
      }
      if (!this.pathStartNode.ownerDocument.body.contains(this.pathStartNode)) {
        this.log.debug("We cannot map nodes that are not attached.");
        return this.path;
      }
      this.log.debug("No valid cache, will have to do a scan.");
      this.documentChanged();
      startTime = this.timestamp();
      this.path = {};
      pathStart = this.getDefaultPath();
      task = {
        node: this.pathStartNode,
        path: pathStart
      };
      this.saveSelection();
      this.finishTraverseSync(task);
      this.restoreSelection();
      t1 = this.timestamp();
      this.log.info("Phase I (Path traversal) took " + (t1 - startTime) + " ms.");
      node = this.path[pathStart].node;
      this.collectPositions(node, pathStart, null, 0, 0);
      this.lastScanned = this.timestamp();
      this.corpus = this.path[pathStart].content;
      t2 = this.timestamp();
      this.log.info("Phase II (offset calculation) took " + (t2 - t1) + " ms.");
      this.path;
      return null;
    };

    DomTextMapper.prototype.scanAsync = function(onProgress, onFinished) {
      var pathStart, startTime, task,
        _this = this;
      if (this.domStableSince(this.lastScanned)) {
        this.log.debug("We have a valid DOM structure cache. Not scanning.");
        onFinished(this.path);
      }
      this.log.debug("No valid cache, will have to do a scan.");
      this.documentChanged();
      startTime = this.timestamp();
      this.path = {};
      pathStart = this.getDefaultPath();
      task = {
        node: this.pathStartNode,
        path: pathStart
      };
      this.finishTraverseAsync(task, onProgress, function() {
        var node;
        node = _this.path[pathStart].node;
        _this.collectPositions(node, pathStart, null, 0, 0);
        _this.lastScanned = _this.timestamp();
        _this.corpus = _this.path[pathStart].content;
        return onFinished(_this.path);
      });
      return null;
    };

    DomTextMapper.prototype.selectPath = function(path, scroll) {
      var info, node;
      if (scroll == null) {
        scroll = false;
      }
      info = this.path[path];
      if (info == null) {
        throw new Error("I have no info about a node at " + path);
      }
      node = info != null ? info.node : void 0;
      node || (node = this.lookUpNode(info.path));
      return this.selectNode(node, scroll);
    };

    DomTextMapper.prototype.performSyncUpdateOnNode = function(node, escalating) {
      var data, oldIndex, p, parentNode, parentPath, parentPathInfo, path, pathInfo, pathsToDrop, prefix, prevSiblingPathInfo, startTime, task, _i, _len, _ref;
      if (escalating == null) {
        escalating = false;
      }
      if (node == null) {
        throw new Error("Called performSyncUpdateOnOde with a null node!");
      }
      if (this.path == null) {
        return;
      }
      startTime = this.timestamp();
      if (!escalating) {
        this.saveSelection();
      }
      path = this.getPathTo(node);
      pathInfo = this.path[path];
      if (pathInfo == null) {
        this.performSyncUpdateOnNode(node.parentNode, true);
        if (!escalating) {
          this.restoreSelection();
        }
        return;
      }
      this.log.debug("Performing update on node @ path " + path);
      if (escalating) {
        this.log.debug("(Escalated)");
      }
      this.log.trace("Updating data about " + path + ": ");
      if (pathInfo.node === node && pathInfo.content === this.getNodeContent(node, false)) {
        this.log.trace("Good, the node and the overall content is still the same");
        this.log.trace("Dropping obsolete path info for children...");
        prefix = path + "/";
        pathsToDrop = p;
        pathsToDrop = [];
        _ref = this.path;
        for (p in _ref) {
          data = _ref[p];
          if (this.stringStartsWith(p, prefix)) {
            pathsToDrop.push(p);
          }
        }
        for (_i = 0, _len = pathsToDrop.length; _i < _len; _i++) {
          p = pathsToDrop[_i];
          delete this.path[p];
        }
        task = {
          path: path,
          node: node
        };
        this.finishTraverseSync(task);
        this.log.trace("Done. Collecting new path info...");
        if (pathInfo.node === this.pathStartNode) {
          this.log.debug("Ended up rescanning the whole doc.");
          this.collectPositions(node, path, null, 0, 0);
        } else {
          parentPath = this.parentPath(path);
          parentPathInfo = this.path[parentPath];
          if (parentPathInfo == null) {
            throw new Error("While performing update on node " + path + ", no path info found for parent path: " + parentPath);
          }
          oldIndex = node === node.parentNode.firstChild ? 0 : (prevSiblingPathInfo = this.path[this.getPathTo(node.previousSibling)], prevSiblingPathInfo.end - parentPathInfo.start);
          this.collectPositions(node, path, parentPathInfo.content, parentPathInfo.start, oldIndex);
        }
        this.log.debug("Data update took " + (this.timestamp() - startTime) + " ms.");
      } else {
        this.log.trace("Hm..node has been replaced, or overall content has changed!");
        if (pathInfo.node !== this.pathStartNode) {
          this.log.trace("I guess I must go up one level.");
          parentNode = node.parentNode != null ? (this.log.trace("Node has parent, using that."), node.parentNode) : (parentPath = this.parentPath(path), this.log.trace("Node has no parent, will look up " + parentPath), this.lookUpNode(parentPath));
          this.performSyncUpdateOnNode(parentNode, true);
        } else {
          throw new Error("Can not keep up with the changes, since even the node configured as path start node was replaced.");
        }
      }
      if (!escalating) {
        return this.restoreSelection();
      }
    };

    DomTextMapper.prototype.getInfoForPath = function(path) {
      var result;
      if (this.path == null) {
        throw new Error("Can't get info before running a scan() !");
      }
      result = this.path[path];
      if (result == null) {
        throw new Error("Found no info for path '" + path + "'!");
      }
      return result;
    };

    DomTextMapper.prototype.getInfoForNode = function(node) {
      if (node == null) {
        throw new Error("Called getInfoForNode(node) with null node!");
      }
      return this.getInfoForPath(this.getPathTo(node));
    };

    DomTextMapper.prototype.getMappingsForCharRanges = function(charRanges) {
      var charRange, mapping, _i, _len, _results;
      log.debug("Getting mappings for charRanges:");
      log.debug(charRanges);
      _results = [];
      for (_i = 0, _len = charRanges.length; _i < _len; _i++) {
        charRange = charRanges[_i];
        _results.push(mapping = this.getMappingsForCharRange(charRange.start, charRange.end));
      }
      return _results;
    };

    DomTextMapper.prototype.getContentForPath = function(path) {
      if (path == null) {
        path = null;
      }
      if (this.path == null) {
        throw new Error("Can't get info before running a scan() !");
      }
      if (path == null) {
        path = this.getDefaultPath();
      }
      return this.path[path].content;
    };

    DomTextMapper.prototype.getLengthForPath = function(path) {
      if (path == null) {
        path = null;
      }
      if (path == null) {
        path = this.getDefaultPath();
      }
      return this.path[path].length;
    };

    DomTextMapper.prototype.getDocLength = function() {
      return this.getLengthForPath();
    };

    DomTextMapper.prototype.getContentForCharRange = function(start, end, path) {
      var text;
      if (path == null) {
        path = null;
      }
      text = this.getContentForPath(path).substr(start, end - start);
      return text.trim();
    };

    DomTextMapper.prototype.getContextForCharRange = function(start, end, path) {
      var content, prefix, prefixLen, prefixStart, suffix;
      if (path == null) {
        path = null;
      }
      content = this.getContentForPath(path);
      prefixStart = Math.max(0, start - CONTEXT_LEN);
      prefixLen = start - prefixStart;
      prefix = content.substr(prefixStart, prefixLen);
      suffix = content.substr(end, prefixLen);
      return [prefix.trim(), suffix.trim()];
    };

    DomTextMapper.prototype.getMappingsForCharRange = function(start, end) {
      var endInfo, endMapping, endNode, endOffset, endPath, info, mappings, p, r, result, startInfo, startMapping, startNode, startOffset, startPath, _ref,
        _this = this;
      if (!((start != null) && (end != null))) {
        throw new Error("start and end is required!");
      }
      this.log.trace("Collecting nodes for [" + start + ":" + end + "]");
      if (!this.domStableSince(this.lastScanned)) {
        throw new Error("Can not get mappings, since the dom has changed since last scanned. Call scan first.");
      }
      this.log.trace("Collecting mappings");
      mappings = [];
      _ref = this.path;
      for (p in _ref) {
        info = _ref[p];
        if (info.atomic && this.regions_overlap(info.start, info.end, start, end)) {
          (function(info) {
            var full, mapping;
            _this.log.trace("Checking " + info.path);
            _this.log.trace(info);
            mapping = {
              element: info
            };
            full = start <= info.start && info.end <= end;
            if (full) {
              mapping.full = true;
              mapping.wanted = info.content;
              mapping.yields = info.content;
              mapping.startCorrected = 0;
              mapping.endCorrected = 0;
            } else {
              if (info.node.nodeType === Node.TEXT_NODE) {
                if (start <= info.start) {
                  mapping.end = end - info.start;
                  mapping.wanted = info.content.substr(0, mapping.end);
                } else if (info.end <= end) {
                  mapping.start = start - info.start;
                  mapping.wanted = info.content.substr(mapping.start);
                } else {
                  mapping.start = start - info.start;
                  mapping.end = end - info.start;
                  mapping.wanted = info.content.substr(mapping.start, mapping.end - mapping.start);
                }
                _this.computeSourcePositions(mapping);
                mapping.yields = info.node.data.substr(mapping.startCorrected, mapping.endCorrected - mapping.startCorrected);
              } else if ((info.node.nodeType === Node.ELEMENT_NODE) && (info.node.tagName.toLowerCase() === "img")) {
                _this.log.debug("Can not select a sub-string from the title of an image. Selecting all.");
                mapping.full = true;
                mapping.wanted = info.content;
              } else {
                _this.log.warn("Warning: no idea how to handle partial mappings for node type " + info.node.nodeType);
                if (info.node.tagName != null) {
                  _this.log.warn("Tag: " + info.node.tagName);
                }
                _this.log.warn("Selecting all.");
                mapping.full = true;
                mapping.wanted = info.content;
              }
            }
            mappings.push(mapping);
            return _this.log.trace("Done with " + info.path);
          })(info);
        }
      }
      if (mappings.length === 0) {
        throw new Error("No mappings found for [" + start + ":" + end + "]!");
      }
      mappings = mappings.sort(function(a, b) {
        return a.element.start - b.element.start;
      });
      this.log.trace("Building range...");
      r = this.rootWin.document.createRange();
      startMapping = mappings[0];
      startNode = startMapping.element.node;
      startPath = startMapping.element.path;
      startOffset = startMapping.startCorrected;
      if (startMapping.full) {
        r.setStartBefore(startNode);
        startInfo = startPath;
      } else {
        r.setStart(startNode, startOffset);
        startInfo = startPath + ":" + startOffset;
      }
      endMapping = mappings[mappings.length - 1];
      endNode = endMapping.element.node;
      endPath = endMapping.element.path;
      endOffset = endMapping.endCorrected;
      if (endMapping.full) {
        r.setEndAfter(endNode);
        endInfo = endPath;
      } else {
        r.setEnd(endNode, endOffset);
        endInfo = endPath + ":" + endOffset;
      }
      result = {
        mappings: mappings,
        realRange: r,
        rangeInfo: {
          startPath: startPath,
          startOffset: startOffset,
          startInfo: startInfo,
          endPath: endPath,
          endOffset: endOffset,
          endInfo: endInfo
        },
        safeParent: r.commonAncestorContainer
      };
      this.log.trace("Done collecting");
      return result;
    };

    DomTextMapper.prototype.timestamp = function() {
      return new Date().getTime();
    };

    DomTextMapper.prototype.stringStartsWith = function(string, prefix) {
      return prefix === string.substr(0, prefix.length);
    };

    DomTextMapper.prototype.stringEndsWith = function(string, suffix) {
      return suffix === string.substr(string.length - suffix.length);
    };

    DomTextMapper.prototype.parentPath = function(path) {
      return path.substr(0, path.lastIndexOf("/"));
    };

    DomTextMapper.prototype.domChangedSince = function(timestamp) {
      if ((this.lastDOMChange != null) && (timestamp != null)) {
        return this.lastDOMChange > timestamp;
      } else {
        return true;
      }
    };

    DomTextMapper.prototype.domStableSince = function(timestamp) {
      return !this.domChangedSince(timestamp);
    };

    DomTextMapper.prototype.getProperNodeName = function(node) {
      var nodeName;
      nodeName = node.nodeName;
      switch (nodeName) {
        case "#text":
          return "text()";
        case "#comment":
          return "comment()";
        case "#cdata-section":
          return "cdata-section()";
        default:
          return nodeName;
      }
    };

    DomTextMapper.prototype.getNodePosition = function(node) {
      var pos, tmp;
      pos = 0;
      tmp = node;
      while (tmp) {
        if (tmp.nodeName === node.nodeName) {
          pos++;
        }
        tmp = tmp.previousSibling;
      }
      return pos;
    };

    DomTextMapper.prototype.getPathSegment = function(node) {
      var name, pos;
      name = this.getProperNodeName(node);
      pos = this.getNodePosition(node);
      return name + (pos > 1 ? "[" + pos + "]" : "");
    };

    DomTextMapper.prototype.getPathTo = function(node) {
      var xpath;
      xpath = '';
      while (node !== this.rootNode) {
        if (node == null) {
          throw new Error("Called getPathTo on a node which was not a descendant of @rootNode. " + this.rootNode);
        }
        xpath = (this.getPathSegment(node)) + '/' + xpath;
        node = node.parentNode;
      }
      xpath = (this.rootNode.ownerDocument != null ? './' : '/') + xpath;
      xpath = xpath.replace(/\/$/, '');
      return xpath;
    };

    DomTextMapper.prototype.executeTraverseTask = function(task) {
      var child, cont, invisiable, invisible, node, path, verbose, _i, _len, _ref, _ref1, _ref2;
      node = task.node;
      this.underTraverse = path = task.path;
      invisiable = (_ref = task.invisible) != null ? _ref : false;
      verbose = (_ref1 = task.verbose) != null ? _ref1 : false;
      this.log.trace("Executing traverse task for path " + path);
      cont = this.getNodeContent(node, false);
      this.path[path] = {
        path: path,
        content: cont,
        length: cont.length,
        node: node
      };
      if (cont.length) {
        if (verbose) {
          this.log.info("Collected info about path " + path);
        } else {
          this.log.trace("Collected info about path " + path);
        }
        if (invisible) {
          this.log.warn("Something seems to be wrong. I see visible content @ " + path + ", while some of the ancestor nodes reported empty contents." + " Probably a new selection API bug....");
        }
      } else {
        if (verbose) {
          this.log.info("Found no content at path " + path);
        } else {
          this.log.trace("Found no content at path " + path);
        }
        invisible = true;
      }
      if (node.hasChildNodes()) {
        _ref2 = node.childNodes;
        for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
          child = _ref2[_i];
          this.traverseTasks.push({
            node: child,
            path: path + '/' + (this.getPathSegment(child)),
            invisible: invisible,
            verbose: verbose
          });
        }
      }
      return null;
    };

    DomTextMapper.prototype.runTraverseRounds = function() {
      var exception, progress, roundStart, task, tasksDone,
        _this = this;
      try {
        this.saveSelection();
        roundStart = this.timestamp();
        tasksDone = 0;
        while (this.traverseTasks.length && (this.timestamp() - roundStart < SCAN_JOB_LENGTH_MS)) {
          this.log.trace("Queue length is: " + this.traverseTasks.length);
          task = this.traverseTasks.pop();
          this.executeTraverseTask(task);
          tasksDone += 1;
          if (!task.node.hasChildNodes()) {
            this.traverseCoveredChars += this.path[task.path].length;
          }
          this.log.trace("Round covered " + tasksDone + " tasks " + "in " + (this.timestamp() - roundStart) + " ms." + " Covered chars: " + this.traverseCoveredChars);
        }
        this.restoreSelection();
        if (this.traverseOnProgress != null) {
          progress = this.traverseCoveredChars / this.traverseTotalLength;
          this.traverseOnProgress(progress);
        }
        if (this.traverseTasks.length) {
          return window.setTimeout(function() {
            return _this.runTraverseRounds();
          });
        } else {
          return this.traverseOnFinished();
        }
      } catch (_error) {
        exception = _error;
        return this.log.error("Internal error while traversing", exception);
      }
    };

    DomTextMapper.prototype.finishTraverseSync = function(rootTask) {
      var _results;
      if ((this.traverseTasks != null) && this.traverseTasks.size) {
        throw new Error("A DOM traverse is already in progress!");
      }
      this.traverseTasks = [];
      this.executeTraverseTask(rootTask);
      this.traverseTotalLength = this.path[rootTask.path].length;
      this.traverseCoveredChars = 0;
      _results = [];
      while (this.traverseTasks.length) {
        _results.push(this.executeTraverseTask(this.traverseTasks.pop()));
      }
      return _results;
    };

    DomTextMapper.prototype.finishTraverseAsync = function(rootTask, onProgress, onFinished) {
      var _this = this;
      if ((this.traverseTasks != null) && this.traverseTasks.size) {
        throw new Error("A DOM traverse is already in progress!");
      }
      this.traverseTasks = [];
      this.saveSelection();
      this.executeTraverseTask(rootTask);
      this.restoreSelection();
      this.traverseTotalLength = this.path[rootTask.path].length;
      this.traverseOnProgress = onProgress;
      this.traverseCoveredChars = 0;
      this.traverseOnFinished = onFinished;
      return window.setTimeout(function() {
        return _this.runTraverseRounds();
      });
    };

    DomTextMapper.prototype.getBody = function() {
      return (this.rootWin.document.getElementsByTagName("body"))[0];
    };

    DomTextMapper.prototype.regions_overlap = function(start1, end1, start2, end2) {
      return start1 < end2 && start2 < end1;
    };

    DomTextMapper.prototype.lookUpNode = function(path) {
      var doc, node, results, _ref;
      doc = (_ref = this.rootNode.ownerDocument) != null ? _ref : this.rootNode;
      results = doc.evaluate(path, this.rootNode, null, 0, null);
      return node = results.iterateNext();
    };

    DomTextMapper.prototype.saveSelection = function() {
      var i, sel, _i, _ref;
      if (this.savedSelection != null) {
        throw new Error("Selection already saved! Here:" + this.selectionSaved + "\n\n" + "New attempt to save:");
      }
      sel = this.rootWin.getSelection();
      this.log.debug("Saving selection: " + sel.rangeCount + " ranges.");
      for (i = _i = 0, _ref = sel.rangeCount; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
        this.savedSelection = sel.getRangeAt(i);
      }
      switch (sel.rangeCount) {
        case 0:
          if (this.savedSelection == null) {
            this.savedSelection = [];
          }
          break;
        case 1:
          this.savedSelection = [this.savedSelection];
      }
      return this.selectionSaved = (new Error("")).stack;
    };

    DomTextMapper.prototype.restoreSelection = function() {
      var range, sel, _i, _len, _ref;
      this.log.trace("Restoring selection: " + this.savedSelection.length + " ranges.");
      if (this.savedSelection == null) {
        throw new Error("No selection to restore.");
      }
      sel = this.rootWin.getSelection();
      sel.removeAllRanges();
      _ref = this.savedSelection;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        range = _ref[_i];
        sel.addRange(range);
      }
      return delete this.savedSelection;
    };

    DomTextMapper.prototype.selectNode = function(node, scroll) {
      var children, exception, realRange, sel, sn, _ref;
      if (scroll == null) {
        scroll = false;
      }
      if (node == null) {
        throw new Error("Called selectNode with null node!");
      }
      sel = this.rootWin.getSelection();
      sel.removeAllRanges();
      realRange = this.rootWin.document.createRange();
      if (node.nodeType === Node.ELEMENT_NODE && node.hasChildNodes() && (_ref = node.tagName.toLowerCase(), __indexOf.call(SELECT_CHILDREN_INSTEAD, _ref) >= 0)) {
        children = node.childNodes;
        realRange.setStartBefore(children[0]);
        realRange.setEndAfter(children[children.length - 1]);
        sel.addRange(realRange);
      } else {
        if (USE_TABLE_TEXT_WORKAROUND && node.nodeType === Node.TEXT_NODE && node.parentNode.tagName.toLowerCase() === "table") {

        } else {
          try {
            realRange.setStartBefore(node);
            realRange.setEndAfter(node);
            sel.addRange(realRange);
          } catch (_error) {
            exception = _error;
            if (!(USE_EMPTY_TEXT_WORKAROUND && this.isWhitespace(node))) {
              this.log.warn("Warning: failed to scan element @ " + this.underTraverse);
              this.log.warn("Content is: " + node.innerHTML);
              this.log.warn("We won't be able to properly anchor to any text inside this element.");
            }
          }
        }
      }
      if (scroll) {
        sn = node;
        while ((sn != null) && (sn.scrollIntoViewIfNeeded == null)) {
          sn = sn.parentNode;
        }
        if (sn != null) {
          sn.scrollIntoViewIfNeeded();
        } else {
          this.log.warn("Failed to scroll to element. (Browser does not support scrollIntoViewIfNeeded?)");
        }
      }
      return sel;
    };

    DomTextMapper.prototype.readSelectionText = function(sel) {
      sel || (sel = this.rootWin.getSelection());
      return sel.toString().trim().replace(/\n/g, " ").replace(/\s{2,}/g, " ");
    };

    DomTextMapper.prototype.getNodeSelectionText = function(node, shouldRestoreSelection) {
      var sel, text;
      if (shouldRestoreSelection == null) {
        shouldRestoreSelection = true;
      }
      if (shouldRestoreSelection) {
        this.saveSelection();
      }
      sel = this.selectNode(node);
      text = this.readSelectionText(sel);
      if (shouldRestoreSelection) {
        this.restoreSelection();
      }
      return text;
    };

    DomTextMapper.prototype.computeSourcePositions = function(match) {
      var dc, displayEnd, displayIndex, displayStart, displayText, sc, sourceEnd, sourceIndex, sourceStart, sourceText;
      this.log.trace("In computeSourcePosition");
      this.log.trace("Path is '" + match.element.path + "'");
      this.log.trace("Node data is: ", match.element.node.data);
      sourceText = match.element.node.data.replace(/\n/g, " ");
      this.log.trace("sourceText is '" + sourceText + "'");
      displayText = match.element.content;
      this.log.trace("displayText is '" + displayText + "'");
      displayStart = match.start != null ? match.start : 0;
      displayEnd = match.end != null ? match.end : displayText.length;
      this.log.trace("Display charRange is: " + displayStart + "-" + displayEnd);
      if (displayEnd === 0) {
        match.startCorrected = 0;
        match.endCorrected = 0;
        return;
      }
      sourceIndex = 0;
      displayIndex = 0;
      while (!((sourceStart != null) && (sourceEnd != null))) {
        if (sourceIndex === sourceText.length) {
          throw new Error("Error! This node (at '" + match.element.path + "') looks different compared to what I remember! Maybe the document was updated, but d-t-m was not notified?");
        }
        sc = sourceText[sourceIndex];
        dc = displayText[displayIndex];
        if (sc === dc) {
          if (displayIndex === displayStart) {
            sourceStart = sourceIndex;
          }
          displayIndex++;
          if (displayIndex === displayEnd) {
            sourceEnd = sourceIndex + 1;
          }
        }
        sourceIndex++;
      }
      match.startCorrected = sourceStart;
      match.endCorrected = sourceEnd;
      this.log.trace("computeSourcePosition done. Corrected charRange is: " + match.startCorrected + "-" + match.endCorrected);
      return null;
    };

    DomTextMapper.prototype.getNodeContent = function(node, shouldRestoreSelection) {
      if (shouldRestoreSelection == null) {
        shouldRestoreSelection = true;
      }
      return this.getNodeSelectionText(node, shouldRestoreSelection);
    };

    DomTextMapper.prototype.collectPositions = function(node, path, parentContent, parentIndex, index) {
      var atomic, child, childPath, children, content, endIndex, i, newCount, nodeName, oldCount, pathInfo, pos, startIndex, typeCount;
      if (parentContent == null) {
        parentContent = null;
      }
      if (parentIndex == null) {
        parentIndex = 0;
      }
      if (index == null) {
        index = 0;
      }
      this.log.trace("Scanning path " + path);
      pathInfo = this.path[path];
      if (pathInfo == null) {
        this.log.error("I have no info about " + path + ". This should not happen.");
        this.log.error("Node:");
        this.log.error(node);
        this.log.error("This probably was _not_ here last time. Expect problems.");
        return index;
      }
      content = pathInfo != null ? pathInfo.content : void 0;
      if ((content == null) || content === "") {
        pathInfo.start = parentIndex + index;
        pathInfo.end = parentIndex + index;
        pathInfo.atomic = false;
        return index;
      }
      startIndex = parentContent != null ? parentContent.indexOf(content, index) : index;
      if (startIndex === -1) {
        this.log.trace("Content of this not is not present in content of parent, " + "at path " + path);
        return index;
      }
      endIndex = startIndex + content.length;
      atomic = !node.hasChildNodes();
      pathInfo.start = parentIndex + startIndex;
      pathInfo.end = parentIndex + endIndex;
      pathInfo.atomic = atomic;
      if (!atomic) {
        children = node.childNodes;
        i = 0;
        pos = 0;
        typeCount = Object();
        while (i < children.length) {
          child = children[i];
          nodeName = this.getProperNodeName(child);
          oldCount = typeCount[nodeName];
          newCount = oldCount != null ? oldCount + 1 : 1;
          typeCount[nodeName] = newCount;
          childPath = path + "/" + nodeName + (newCount > 1 ? "[" + newCount + "]" : "");
          pos = this.collectPositions(child, childPath, content, parentIndex + startIndex, pos);
          i++;
        }
      }
      return endIndex;
    };

    WHITESPACE = /^\s*$/;

    DomTextMapper.prototype.isWhitespace = function(node) {
      var child, mightBeEmpty, result;
      result = (function() {
        var _i, _len, _ref;
        switch (node.nodeType) {
          case Node.TEXT_NODE:
            return WHITESPACE.test(node.data);
          case Node.ELEMENT_NODE:
            mightBeEmpty = true;
            _ref = node.childNodes;
            for (_i = 0, _len = _ref.length; _i < _len; _i++) {
              child = _ref[_i];
              mightBeEmpty = mightBeEmpty && this.isWhitespace(child);
            }
            return mightBeEmpty;
          default:
            return false;
        }
      }).call(this);
      return result;
    };

    return DomTextMapper;

  })();

}).call(this);

/*
//@ sourceMappingURL=dom_text_mapper.map
*/
